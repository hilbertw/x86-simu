#include "cpu.h"
#include "addressmap.h"

#include "log.h"

void __cdecl vt_show_a20(bool on);

static char port92;
extern unsigned char  output_port_8042;
extern CCPU  cpu[];

void reset(int i);
void a20_sync();
//Fast A20 and Init Register
void cpu_if(
	  void *lpContext,
	  ADDR_RANGE_CMD op, 
	  unsigned int dwAddress,           // start dwAddress on 32bit bus
	  char *pszBuff,                    // optional 
	  unsigned int nBytes )            // in or out buffer
 {


	 switch(op)
	 {
	 case ADDR_RANGE_READ: 
		 if(nBytes==1)  *pszBuff=port92|1;// dont report INIT# 
		 break;

	 case ADDR_RANGE_WRITE: // reser generator
		//INIT_NOW - R/W. When this bit transitions from a 0 to a 1, the Intel ICH4 will force INIT# active
		//for 16 PCI clocks.
		// if((*pszBuff &1)==1&&(port92&1)==0)

		if ((pszBuff[0]&1) ==1 )
			 reset(2);

		 port92=*pszBuff;// dont report INIT# 
		 a20_sync();
		 break;

	 default:
		 return;
	 }

#if LOG_PORT92
	 log4(
		 "Port 92",
		 op==ADDR_RANGE_READ?'r':'w',
		 dwAddress,	
	 	nBytes==1? (unsigned char)pszBuff[0]:
		nBytes==2? *(unsigned short *)pszBuff:
		nBytes==4? *(unsigned long *)pszBuff:0);
#endif
 }
//
//The A20M# signal will be active (low) when both of the following conditions are true:
//The ALT_A20_GATE bit (Bit 1 of PORT92 register) is a 0
//The A20GATE input signal is a 0
//The A20GATE input signal is expected to be generated by the external microcontroller (KBC).
void a20_sync()
{
	bool on=(port92&2)!=0|| (output_port_8042&2)!=0;

	if(!on) cpu[0].disable_a20();
	else cpu[0].enable_a20();
#if LOG_A20
	log("A20:%s (port92:%x), (8042 output port:%x)\n",
		on?"enabled":"disabled",
		port92,
		output_port_8042);
#endif

	vt_show_a20(on);
}

void reset_a20()
{
	port92=0;
	a20_sync();
}