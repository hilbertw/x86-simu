#include "cpu.h"
#pragma warning (disable:4018)
#pragma warning (disable:4013)

//__PE__==0, REAL-ADDRESS-MODE;	
void CCPU::int_real86 (unsigned int vector_number)
{
	
	if (vector_number * 4 + 3 >= idt_limit)  //if (((DEST * 4) + 3) is not within IDT limit,
		GP(0);                               //   #GP; 

	if (!check_stack_for_push (6) )  //if stack not large enough for a 6-byte return information
		SS(0);             //  #SS; 

	PUSHW (__CFLAGS__);     //EFLAGS[15:0]
	__IF__ =  0;           // Clear interrupt flag 
	__TF__ =  0;            // Clear trap flag 
	__AC__ =  0;            //Clear AC flag

	PUSHW(___CS___);
	PUSHW( __NEXT_EIP__ );
	/* No error codes are pushed */

	unsigned short cs = MEM_READW ( vector_number * 4 + 2);
	load_seg_real_or_v86(CS,cs);
    /* 16 bit offset AND 0000FFFFH */
	__NEXT_EIP__=
	__EIP__ = MEM_READW ( vector_number * 4); 

}
/* __PE__==1, protected mode or virtual-8086 mode interrupt */
void CCPU::int_protected (unsigned int vector_number, 
					unsigned char INTn, unsigned int error_code, 
					unsigned with_error_code,  int  OperandSize)
{
	if (__VM__ == 1 && __IOPL__ < 3 && INTn) GP(0);

//PROTECTED-MODE:

	/* EXT is bit 0 in error code */
	bool  EXT= error_code&1;

	if (vector_number * 8 + 7 > idt_limit)      //((DEST * 8) + 7) is not within IDT limits
		GP (vector_number * 8 + 2 + EXT);       //     #GP((DEST * 8) + 2 + EXT);
		                                        // EXT is bit 0 in error code
	
	//Read trap or interrupt handler descriptor;
	load_descriptor(idt_base,&INTGATE_DESC,vector_number);

	if (!INTERRUPT_GATE(INTGATE_DESC) )              //selected IDT descriptor is not an 
		                                        //     interrupt-, trap-, or task-gate type
		GP (vector_number * 8 + 2 + EXT);       //     #GP((DEST * 8) + 2 + EXT);
		                                        // EXT is bit 0 in error code

	/* __PE__=1, DPL<CPL, software interrupt */
	if (INTn )                                  // software interrupt,generated by INT n, 
	{                                           // INT 3, or INTO 
		if (DPL (INTGATE_DESC) < __CPL__ )              //if gate descriptor DPL < CPL,
			GP (vector_number * 8 + 2);         //     #GP((vector_number * 8) + 2 );
		
	} 
	if (!PRESENT (INTGATE_DESC))                        // if gate not present,
         GP (vector_number * 8 + 2 + EXT);      //     #NP((vector_number * 8) + 2 + EXT); 


	/*task gate,specified in the selected interrupt table descriptor  */
	if (TASK_GATE (INTGATE_DESC)) {            /* __PE__=1, task gate */      

		int_task_gate(error_code,with_error_code);

	} else 	{

     /*  __PE__=1, trap/interrupt gate, TRAP-OR-INTERRUPT-GATE */
	
		SELECTOR cs;
		unsigned int dt_base;
		unsigned short dt_limit;

		cs = GATE_SELECTOR (INTGATE_DESC); // Read segment selector for trap or interrupt gate (IDT descriptor);
		if (NULL_SELECTOR (cs))    // segment selector for code segment is null
			GP (0 + EXT );         //      #GP(0H + EXT); null selector with EXT flag set 

		// if segment selector is not within its descriptor table limits) 
		dt_base  = IN_GDT(cs) ? gdt_base : ldt_base;
		dt_limit = IN_GDT(cs) ? gdt_limit: ldt_limit;

		if (SELECTOR_TOP(cs) > dt_limit) GP(MK_SHORT(cs) + EXT);  //#GP(selector + EXT);

		//Read trap or interrupt handler descriptor;
		load_descriptor(dt_base,&CS_DESC,cs.index);

		if ( (!CODE_SEG (CS_DESC))           //if descriptor does not indicate a code segment 
			   || DPL (CS_DESC) > __CPL__ ) //    OR code segment descriptor DPL > CPL
			GP (MK_SHORT (cs) + EXT);    //    #GP(selector + EXT);

		if (!PRESENT (CS_DESC))             // if trap or interrupt gate segment is not present,
			NP (MK_SHORT (cs) + EXT);    //    #NP(selector + EXT);

        /* __PE__=1, interrupt or trap gate, non-conforming code segment, DPL<CPL */
		
		if ((!CONFORMING (CS_DESC))        // if code segment is non-conforming 
			&& DPL (CS_DESC) < __CPL__ )   //     AND DPL < CPL
		{ 
	
			if (__VM__==0 )           
				int_inter_previlege(cs,error_code,with_error_code,OperandSize);
			else   /* __VM__=1 */
			{
				//IF code segment DPL<>0 THEN #GP(new code segment selector); 
				if (DPL (CS_DESC) !=0 ) GP (MK_SHORT (cs));      

				int_v86(cs,error_code,with_error_code,OperandSize);
			}

		 /* __PE__=1, interrupt or trap gate, DPL >= CPL */
		} else{
			//IF VM=1 THEN #GP(new code segment selector); 
			if(__VM__==1) GP(MK_SHORT (cs) );

			// if code segment is conforming OR code segment DPL = CPL
			if (CONFORMING (CS_DESC)         
				|| DPL (CS_DESC) == __CPL__)     
						
			//INTRA-PRIVILEGE-LEVEL-INTERRUPT:
			/* __PE__=1, DPL = CPL or conforming segment */
				 int_intra_privilege(cs,error_code,with_error_code,OperandSize);

			 else 
			//
			// __PE__=1, interrupt or trap gate, nonconforming, code segment, DPL>CPL 
			// #GP(CodeSegmentSelector + EXT);
				GP (MK_SHORT (cs) + EXT); 
		}
	}

 	sync_fetch_eip(__NEXT_EIP__);
}
//  interrupte gate desc in tmp_desc1
// code desc in tmp_desc2,
//
// __PE__=1, interrupt or trap gate, nonconforming code segment, DPL<CPL, __VM__=0 
// INTER-PREVILEGE-LEVEL-INTERRUPT
//
void CCPU::int_inter_previlege(SELECTOR cs,int error_code,int with_error_code,int OperandSize)
{
	unsigned short  TempSS  = ___SS___;
	unsigned long  TempESP =  __ESP__;

	SELECTOR NewSS;
	unsigned long  NewESP;
	unsigned long TSSstackAddress;
	char EXT=error_code&1;

/* Check segment selector and descriptor for stack of new privilege level in current TSS */
	if (TSS32 (tr_desc))  // if current TSS is 32-bit TSS
	{

		//TSSstackAddress  (new code segment DPL * 8) + 4
		TSSstackAddress = DPL (CS_DESC) * 8 + 4;
		//IF (TSSstackAddress + 7) > TSS limit
		//THEN #TS(current TSS selector); 
		if ((TSSstackAddress + 7) > LIMIT (tr_desc))  
			TS (___TR___);                      
		//NewSS <-TSSstackAddress + 4;
		//NewESP<- stack address;
		NewESP = MEM_READL (BASE (tr_desc) + TSSstackAddress );
		 MK_SHORT (NewSS)  = MEM_READW (BASE (tr_desc) + TSSstackAddress + 4);

	} else { /* TSS is 16-bit */
		//TSSstackAddress  (new code segment DPL * 4) + 4
		TSSstackAddress = DPL (CS_DESC) * 4 + 2;
		if ((TSSstackAddress + 4) > LIMIT (tr_desc))  // TSS limit
			TS (___TR___);                     // #TS(current TSS selector); 
		//NewSS <-TSSstackAddress + 2;
		//NewESP<- stack address;
		NewESP           = MEM_READW (BASE (tr_desc) + TSSstackAddress );
		MK_SHORT (NewSS) = MEM_READW (BASE (tr_desc) + TSSstackAddress + 2);
		
	}
	//IF segment selector is null THEN #TS(EXT); FI;
	//IF segment selector index is not within its descriptor table limits
	//OR segment selector's RPL  DPL of code segment, 
	//THEN #TS(SS selector + EXT);
	if (NULL_SELECTOR (NewSS))                
		TS (MK_SHORT (NewSS) + EXT);                              

	unsigned long dt_base  = IN_GDT(NewSS) ? gdt_base : ldt_base;
	unsigned short dt_limit = IN_GDT(NewSS) ? gdt_limit: ldt_limit;


	if (SELECTOR_TOP(NewSS)> dt_limit         
		|| RPL (NewSS) != DPL (CS_DESC))  
		TS (MK_SHORT (NewSS) + EXT);             

	//Read segment descriptor for stack segment in GDT or LDT;
	load_descriptor(gdt_base,&SS_DESC,NewSS.index);
	//IF stack segment DPL  DPL of code segment, 
	//OR stack segment does not indicate writable data segment, 
	//THEN #TS(SS selector + EXT);
	if (DPL (SS_DESC) != DPL (CS_DESC)   
		|| !WRITEABLE (SS_DESC))       
		TS (MK_SHORT (NewSS) + EXT); 
	//IF stack segment not present THEN #SS(SS selector+EXT);
	if (!PRESENT (SS_DESC))           
		SS (MK_SHORT (NewSS) + EXT);  

	if (GATE32 (INTGATE_DESC)) /* 32-bit gate */
	{
		// if new stack does not have room for 24 bytes (error code pushed)
		//   OR 20 bytes (no error code pushed)
		//   #SS(segment selector + EXT);
		if ((with_error_code &&!check_limit(&SS_DESC,NewESP-24,NewESP))          
			||((!with_error_code)&&!check_limit(&SS_DESC,NewESP-20,NewESP) ))   
			SS (MK_SHORT (NewSS) + EXT);                

	} else { /* 16-bit gate */
		//IF new stack does not have room for 12 bytes (error code pushed) 
		//OR 10 bytes (no error code pushed);
		//   #SS(segment selector + EXT);
		if ((with_error_code &&!check_limit(&SS_DESC,NewESP-12,NewESP))          
			||((!with_error_code)&&!check_limit(&SS_DESC,NewESP-10,NewESP) ))  
			SS (MK_SHORT (NewSS) + EXT);                
	}



	unsigned long eip=GATE_OFFSET(INTGATE_DESC);

	//if (instruction pointer is not within code segment limits ) 
	// #GP(0);
	if(eip>LIMIT(CS_DESC))GP(0);
	//SS:ESP  TSS(NewSS:NewESP) (* segment descriptor information also loaded *)
	ss_desc= SS_DESC;/* segment descriptor information also loaded */
	___SS___=MK_SHORT(NewSS);
	__ESP__ = NewESP; 

	if (GATE32 (INTGATE_DESC))              // if 32-bit gate
	{
		/* Push far pointer to old stack:old SS and ESP, 3 words padded to 4 */;
		PUSHL (TempSS);
		PUSHL (TempESP);
		PUSHL (__EFLAGS__);
		/* far pointer to return instruction:old CS and EIP, 3 words padded to 4*/;
		PUSHL(___CS___);
		PUSHL( __NEXT_EIP__);

		if (with_error_code)
			PUSHL (error_code); /* if needed, 4 bytes */

		//___CS___=cs;
		//cs_desc=CS_DESC; /* segment descriptor information also loaded */
		copy_cs_desc(cs,CS_DESC_NO);
		__NEXT_EIP__=
		__EIP__ = eip;

	} else {/* 16-bit gate */
		/* Push far pointer to old stack:old SS and SP, 2 words */;
		PUSHW (TempSS );
		PUSHW ((unsigned short)TempESP);
		PUSHW (__CFLAGS__);
		/* far pointer to return instruction:old CS and IP, 2 words*/;
		PUSHW(___CS___);
		PUSHW( __EIP__);

		if (with_error_code)
			PUSHW (error_code); /* if needed, 2 bytes */

		//___CS___=cs;
		//cs_desc=CS_DESC; /* segment descriptor information also loaded */
		copy_cs_desc(cs,CS_DESC_NO);
		__NEXT_EIP__=
		__IP__ =  (unsigned short) eip;

	}
	//CPL<- CodeSegmentDescriptor(DPL);
	//CS(RPL)<-CPL;
	unsigned char CPL  = DPL(CS_DESC);
	RPL(__CS__) = CPL;
	if (INTERRUPT_GATE (INTGATE_DESC) )    // interrupt gate
	{	 
		__IF__ =  0 /* interrupt flag to 0 (disabled) */;
		__TF__ = 0;
		__VM__ = 0;
		__RF__ = 0;
		__NT__ = 0;
	}
}
// __PE__=1, interrupt or trap gate, DPL<CPL, __VM__=1 
//INTERRUPT-FROM-VIRTUAL-8086-MODE                     
void CCPU::int_v86(SELECTOR cs,int error_code,int with_error_code,int OperandSize)
{
	char EXT=error_code&1;
	SELECTOR NewSS;

	unsigned long  NewESP,TSSstackAddress;
	/* Check segment selector and descriptor for privilege level 0 stack in current TSS */
	if (TSS32 (tr_desc))  // if current TSS is 32-bit TSS
	{

		//TSSstackAddress  (new code segment DPL * 8) + 4
		TSSstackAddress = DPL (CS_DESC) * 8 + 4;
		//IF (TSSstackAddress + 7) > TSS limit
		//THEN #TS(current TSS selector); 
		if ((TSSstackAddress + 7) > LIMIT (tr_desc))  
			TS (___TR___);                      
		//NewSS <-TSSstackAddress + 4;
		//NewESP<- stack address;
		NewESP = MEM_READL (BASE (tr_desc) + TSSstackAddress );
		 MK_SHORT (NewSS)  = MEM_READW (BASE (tr_desc) + TSSstackAddress + 4);

	} else { /* TSS is 16-bit */
		//TSSstackAddress  (new code segment DPL * 4) + 4
		TSSstackAddress = DPL (CS_DESC) * 4 + 2;
		if ((TSSstackAddress + 4) > LIMIT (tr_desc))  // TSS limit
			TS (___TR___);                     // #TS(current TSS selector); 
		//NewSS <-TSSstackAddress + 2;
		//NewESP<- stack address;
		NewESP           = MEM_READW (BASE (tr_desc) + TSSstackAddress );
		MK_SHORT (NewSS) = MEM_READW (BASE (tr_desc) + TSSstackAddress + 2);
		
	}
	//IF segment selector is null THEN #TS(EXT); FI;
	//IF segment selector index is not within its descriptor table limits
	//OR segment selector's RPL  DPL of code segment, 
	//THEN #TS(SS selector + EXT);
	if (NULL_SELECTOR (NewSS))                
		TS (MK_SHORT (NewSS) + EXT);                              

	unsigned long dt_base  = IN_GDT(NewSS) ? gdt_base : ldt_base;
	unsigned short dt_limit = IN_GDT(NewSS) ? gdt_limit: ldt_limit;


	if (SELECTOR_TOP(NewSS) > dt_limit         
		|| RPL (NewSS) != DPL (CS_DESC))  
		TS (MK_SHORT (NewSS) + EXT);             

	//Read segment descriptor for stack segment in GDT or LDT;
	load_descriptor(gdt_base,&SS_DESC,NewSS.index);
	//IF stack segment DPL  DPL of code segment, 
	//OR stack segment does not indicate writable data segment, 
	//THEN #TS(SS selector + EXT);
	if (DPL (SS_DESC) != DPL (CS_DESC)   
		|| !WRITEABLE (SS_DESC))       
		TS (MK_SHORT (NewSS) + EXT); 
	//IF stack segment not present THEN #SS(SS selector+EXT);
	if (!PRESENT (SS_DESC))           
		SS (MK_SHORT (NewSS) + EXT);  

	if (GATE32 (INTGATE_DESC)) /* 32-bit gate */
	{
		//IF new stack does not have room for 40 bytes (error code pushed) 
		//OR 36 bytes (no error code pushed);
		//   #SS(segment selector + EXT);
		if ((with_error_code &&!check_limit(&SS_DESC,NewESP-24,NewESP))          
			||((!with_error_code)&&!check_limit(&SS_DESC,NewESP-20,NewESP) ))   
			SS (MK_SHORT (NewSS) + EXT);                

	} else { /* 16-bit gate */
		//IF new stack does not have room for 20 bytes (error code pushed) 
		//OR 18 bytes (no error code pushed);
		//   #SS(segment selector + EXT);
		if ((with_error_code &&!check_limit(&SS_DESC,NewESP-12,NewESP))          
			||((!with_error_code)&&!check_limit(&SS_DESC,NewESP-10,NewESP) ))  
			SS (MK_SHORT (NewSS) + EXT);                
	}

	unsigned long eip=GATE_OFFSET(INTGATE_DESC);

	//if (instruction pointer is not within code segment limits ) 
	// #GP(0);
	if(eip>LIMIT(CS_DESC))GP(0);
	//tempEFLAGS<-EFLAGS;
	//VM<- 0;
	//TF<- 0;
	//RF<- 0;

	unsigned long TempEFLAGS = __EFLAGS__;
	__VM__ = 0;
	__TF__ = 0;
	__RF__ = 0;
	//IF service through interrupt gate THEN IF  0; 
	if (INTERRUPT_GATE (INTGATE_DESC)) __IF__ =  0;
	unsigned short  TempSS  = ___SS___;
	unsigned long  TempESP =  __ESP__;

	//SS:ESP = TSS(SS0:ESP0): Change to level 0 stack segment */
	unsigned long esp0= MEM_READW (BASE (tr_desc) + OFFSET(TSS,esp0) );
	unsigned short ss0 = MEM_READW (BASE (tr_desc) + OFFSET(TSS,ss0) );

	load_descriptor(gdt_base,&ss_desc,(*(SELECTOR *)&ss0).index);

	___SS___=ss0;
	__ESP__ =esp0; 
	/* Following pushes are 16 bits for 16-bit gate and 32 bits for 32-bit gates */
	/* Segment selector pushes in 32-bit mode are padded to two words */
	PUSHL(___GS___);
	PUSHL(___FS___);
	PUSHL(___DS___);
	PUSHL(___ES___);

	PUSHL(TempSS);
	PUSHL(TempESP);
	PUSHL(TempEFLAGS);

	PUSHL(___CS___);
	PUSHL( __NEXT_EIP__);
	 /*segment registers nullified, invalid in protected mode */
	null_invalid_sreg_selector (__DS__);
	null_invalid_sreg_selector (__FS__);
	null_invalid_sreg_selector (__GS__);
	null_invalid_sreg_selector (__ES__);

	//CS = Gate(CS);
	//cs_desc=CS_DESC; 
	//___CS___=cs;
	copy_cs_desc(cs,CS_DESC_NO);
	if (OperandSize ==  32) 
		__NEXT_EIP__=__EIP__ = eip;   //Gate(instruction pointer);
	else  /* OperandSize is 16 */
		__NEXT_EIP__=__EIP__ = (unsigned short)eip;   //Gate(instruction pointer) AND 0000FFFFH;


	/* Starts execution of new routine in Protected Mode */
}

//INTRA-PRIVILEGE-LEVEL-INTERRUPT:
// __PE__=1, DPL = CPL or conforming segment 
void CCPU::int_intra_privilege(SELECTOR cs,int error_code,int with_error_code,int OperandSize)
{
	unsigned short  TempSS  = ___SS___;
	unsigned long  TempESP =  __ESP__;

	unsigned long eip=GATE_OFFSET(INTGATE_DESC);


		if (GATE32 (INTGATE_DESC)) /* 32-bit gate */
		{
			//IF current stack does not have room for 16 bytes (error code pushed) 
			//OR 12 bytes (no error code pushed); 
			// #SS(0);
			if ( ( !check_stack_for_push (16) &&  with_error_code)          
				||(!check_stack_for_push (12) && !with_error_code))   
				SS (0);									

		} else { /* 16-bit gate */
				//IF current stack does not have room for 8 bytes (error code pushed) 
				//OR 6 bytes (no error code pushed); 
				// #SS(0);
			if ((  !check_stack_for_push (8) &&  with_error_code)          
				||(!check_stack_for_push (6) && !with_error_code))   //   OR 6 bytes (no error code pushed)
				SS (0);                                    //   #SS(0);
		}
	
		//if (instruction pointer is not within code segment limits ) 
		// #GP(0);
		if(eip>LIMIT(CS_DESC))GP(0);

	if (GATE32 (INTGATE_DESC))              // if 32-bit gate
	{
		PUSHL (__EFLAGS__);
		/* far pointer to return instruction:old CS and EIP, 3 words padded to 4*/;
		PUSHL(___CS___);
		PUSHL( __NEXT_EIP__);

		if (with_error_code)
			PUSHL (error_code); /* if needed, 4 bytes */

		//___CS___=cs;
		//cs_desc=CS_DESC; /* segment descriptor information also loaded */
		copy_cs_desc(cs,CS_DESC_NO);
		__NEXT_EIP__=
		__EIP__ = eip;

	} else {/* 16-bit gate */
		/* Push far pointer to old stack:old SS and SP, 2 words */;
		PUSHW (__CFLAGS__);
		/* far pointer to return instruction:old CS and IP, 2 words*/;
		PUSHW(___CS___);
		PUSHW( (unsigned short)__NEXT_EIP__);

		if (with_error_code)
			PUSHW (error_code); /* if needed, 2 bytes */

		//___CS___=cs;
		//cs_desc=CS_DESC; /* segment descriptor information also loaded */
		copy_cs_desc(cs,CS_DESC_NO);
		__NEXT_EIP__=
		__IP__ =  (unsigned short) eip;

	}
	//CPL<- CodeSegmentDescriptor(DPL);
	//CS(RPL)<-CPL;
	//unsigned char CPL  = DPL(CS_DESC);
	//RPL(__CS__) = CPL;
	if (INTERRUPT_GATE (INTGATE_DESC) )    // interrupt gate
	{	 
		__IF__ =  0 /* interrupt flag to 0 (disabled) */;
		__TF__ = 0;
		__VM__ = 0;
		__RF__ = 0;
		__NT__ = 0;
	}
}
void CCPU::int_task_gate(int error_code, unsigned with_error_code)
{
		SELECTOR tss;
     
		tss = GATE_SELECTOR (INTGATE_DESC);   //Read segment selector in task gate (IDT descriptor);
		if ((!IN_GDT (tss))              //if local/global bit is set to local
			|| tss.index >= gdt_limit)//   OR index not within GDT limits
			GP (MK_SHORT (tss));      //    #GP(TSS selector);

		//tss_desc = __GDT__[tss.index];   //Access TSS descriptor in GDT;
		load_descriptor(gdt_base,&TSS_DESC,tss.index);

		if (GATE_BUSYTSS (TSS_DESC))     //if TSS descriptor specifies that the TSS is busy (low-order 5 bits set to 00001)) 
             GP (MK_SHORT (tss));         //    #GP(TSS selector);

		if (!PRESENT (TSS_DESC))         // if TSS not present,
			NP (MK_SHORT (tss));          //    #NP(TSS selector);

		//SWITCH-TASKS (with nesting) to TSS;
		//SWITCH_TASKS
		switch_task(tss,TSS_DESC_NO);// descriptor csched in tmp_desc3

		//IF interrupt caused by fault with error code
		//THEN
		//IF stack limit does not allow push of error code
		//THEN #SS(0);

		if (with_error_code)   
		{
			if (!check_stack_for_push(4))  
				SS (0);         

			PUSHL(error_code);
		}
		//IF EIP not within code segment limit 
		//THEN #GP(0);
}
